#include <SPI.h>

#define B_CLOCK  A1  // horloge
#define B_RESET  A0  // reinitialisation
#define B_RD     2   // lecture
#define B_WR     3   // écriture
#define PL       A3  // stockage dans 74HCT165
#define B_IO     A5  // connecter à /IORQ du Z80 et /CS2 du 16550

// MOSI : 11 n/a
// MISO : 12
// CLK  : 13
// SS   : 10 ne peut être passé en input

#define UCLKDELAY  100   // 0
#define CLKDELAY   0   // 20
#define PLDELAY    100   // 1

//               bit    0 1 2 3 4 5 6  7
int pinsData[8]     = {A2,4,5,6,7,8,9,A4};

volatile int doread=0;
volatile int dowrite=0;

// serial test C puts + compteur
unsigned char mem[] = {
  0x31, 0x00, 0x02, 0x3e, 0x80, 0xd3, 0x03, 0x3e, 0x60, 0xd3, 0x00, 0x3e, 0x00, 0xd3, 0x01, 0x3e,
  0x03, 0xd3, 0x03, 0xcd, 0xa7, 0x01, 0xcd, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x21, 0xb7, 0x01, 0x5e,
  0x16, 0x00, 0xd5, 0x3e, 0x64, 0xf5, 0x33, 0x3a, 0xb7, 0x01, 0xf5, 0x33, 0xcd, 0xd5, 0x00, 0xf1,
  0xd1, 0x26, 0x00, 0x7b, 0x95, 0x6f, 0x7a, 0x9c, 0x67, 0x01, 0x64, 0x00, 0xc5, 0xe5, 0xcd, 0x5e,
  0x01, 0xf1, 0xf1, 0x7d, 0xc6, 0x30, 0xf5, 0x33, 0xcd, 0xc6, 0x00, 0x33, 0x3e, 0x64, 0xf5, 0x33,
  0x3a, 0xb7, 0x01, 0xf5, 0x33, 0xcd, 0xd5, 0x00, 0xf1, 0x5d, 0x16, 0x00, 0xd5, 0x3e, 0x0a, 0xf5,
  0x33, 0x3a, 0xb7, 0x01, 0xf5, 0x33, 0xcd, 0xd5, 0x00, 0xf1, 0xd1, 0x26, 0x00, 0x7b, 0x95, 0x6f,
  0x7a, 0x9c, 0x67, 0x01, 0x0a, 0x00, 0xc5, 0xe5, 0xcd, 0x5e, 0x01, 0xf1, 0xf1, 0x7d, 0xc6, 0x30,
  0xf5, 0x33, 0xcd, 0xc6, 0x00, 0x33, 0x3e, 0x0a, 0xf5, 0x33, 0x3a, 0xb7, 0x01, 0xf5, 0x33, 0xcd,
  0xd5, 0x00, 0xf1, 0x7d, 0xc6, 0x30, 0xf5, 0x33, 0xcd, 0xc6, 0x00, 0x33, 0x3e, 0x20, 0xf5, 0x33,
  0xcd, 0xc6, 0x00, 0x33, 0x21, 0xb3, 0x00, 0xe5, 0xcd, 0x2d, 0x01, 0xf1, 0x21, 0xb7, 0x01, 0x34,
  0xc3, 0x1c, 0x00, 0x43, 0x6f, 0x75, 0x63, 0x6f, 0x75, 0x20, 0x48, 0x61, 0x63, 0x6b, 0x61, 0x62,
  0x6c, 0x65, 0x20, 0x21, 0x0d, 0x00, 0x21, 0x02, 0x00, 0x39, 0xdb, 0x05, 0xcb, 0x6f, 0xca, 0xca,
  0x00, 0x7e, 0xd3, 0x00, 0xc9, 0x21, 0x03, 0x00, 0x39, 0x5e, 0x2b, 0x6e, 0xcd, 0xfb, 0x00, 0xeb,
  0xc9, 0xf1, 0xe1, 0xd1, 0xd5, 0xe5, 0xf5, 0xcd, 0xfe, 0x00, 0xeb, 0xc9, 0xf1, 0xe1, 0xd1, 0xd5,
  0xe5, 0xf5, 0x18, 0x0a, 0x21, 0x03, 0x00, 0x39, 0x5e, 0x2b, 0x6e, 0x26, 0x00, 0x54, 0x7b, 0xe6,
  0x80, 0xb2, 0x20, 0x10, 0x06, 0x10, 0xed, 0x6a, 0x17, 0x93, 0x30, 0x01, 0x83, 0x3f, 0xed, 0x6a,
  0x10, 0xf6, 0x5f, 0xc9, 0x06, 0x09, 0x7d, 0x6c, 0x26, 0x00, 0xcb, 0x1d, 0xed, 0x6a, 0xed, 0x52,
  0x30, 0x01, 0x19, 0x3f, 0x17, 0x10, 0xf5, 0xcb, 0x10, 0x50, 0x5f, 0xeb, 0xc9, 0xdd, 0xe5, 0xdd,
  0x21, 0x00, 0x00, 0xdd, 0x39, 0xdd, 0x6e, 0x04, 0xdd, 0x66, 0x05, 0x11, 0x00, 0x00, 0x46, 0x13,
  0x78, 0xb7, 0x28, 0x0d, 0x23, 0xe5, 0xd5, 0xc5, 0x33, 0xcd, 0xc6, 0x00, 0x33, 0xd1, 0xe1, 0x18,
  0xed, 0xd5, 0x3e, 0x0a, 0xf5, 0x33, 0xcd, 0xc6, 0x00, 0x33, 0xe1, 0xdd, 0xe1, 0xc9, 0xf1, 0xe1,
  0xd1, 0xd5, 0xe5, 0xf5, 0xc3, 0x76, 0x01, 0x21, 0x03, 0x00, 0x39, 0x5e, 0x2b, 0x6e, 0x7d, 0x07,
  0x9f, 0x67, 0x7b, 0x07, 0x9f, 0x57, 0x7c, 0xaa, 0x17, 0x7c, 0xf5, 0x17, 0x30, 0x06, 0x97, 0x95,
  0x6f, 0x9f, 0x94, 0x67, 0xcb, 0x7a, 0x28, 0x06, 0x97, 0x93, 0x5f, 0x9f, 0x92, 0x57, 0xcd, 0xfe,
  0x00, 0xf1, 0xd0, 0x47, 0x97, 0x95, 0x6f, 0x9f, 0x94, 0x67, 0x78, 0xc9, 0x17, 0xeb, 0xd0, 0x97,
  0x95, 0x6f, 0x9f, 0x94, 0x67, 0xc9, 0x42, 0x01, 0x01, 0x00, 0x78, 0xb1, 0x28, 0x08, 0x11, 0xb7,
  0x01, 0x21, 0xa6, 0x01, 0xed, 0xb0, 0xc9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

void readISR() {
  doread=1;
}

void writeISR() {
  dowrite=1;
}

void doClock(unsigned int n) {
  for(int i=0; i<n; i++) {
    digitalWrite(B_CLOCK, HIGH);
    if(UCLKDELAY)
      delayMicroseconds(UCLKDELAY);
    else
      delay(CLKDELAY);

    digitalWrite(B_CLOCK, LOW);
    if(UCLKDELAY)
      delayMicroseconds(UCLKDELAY);
    else
      delay(CLKDELAY);
  }
}

void doReset() {
    digitalWrite(B_RESET, LOW);
    doClock(10);
    digitalWrite(B_RESET, HIGH);
}

unsigned int getaddr() {
  unsigned int addr = 0;

  // MREQ Z80 -> PL ne marche pas car PL doit être HIGH pour lecture série du 74hc165
  // pas comme une EEPROM avec MREQ -> CE et RD -> OE
  digitalWrite(PL, LOW);
  delayMicroseconds(PLDELAY);
  digitalWrite(PL, HIGH);
  delayMicroseconds(PLDELAY);

  byte shift1 = SPI.transfer(0x00);
  byte shift2 = SPI.transfer(0x00);

  addr = shift1;
  addr = (addr << 8);
  addr |= shift2;

  return addr;
}

void setData(unsigned char data) {
  for( int pin = 0; pin < 8; pin++ ) pinMode(pinsData[pin], OUTPUT);  // output

  for(int pin=0; pin<8; pin++) {
    if(data & 1)
      digitalWrite(pinsData[pin], HIGH);
    else
      digitalWrite(pinsData[pin], LOW);
    data >>= 1;
  }
}

// Lecture des  bits de données
unsigned char getData() {
  unsigned char data = 0;
  for(int pin=0; pin<8; pin++) {
    if(digitalRead( pinsData[pin] ) == HIGH ) {
      data |= (1 << pin);
    }
  }
  return data;
}

void setup() {
  digitalWrite(PL, HIGH);
  pinMode(PL, OUTPUT);
  pinMode(B_CLOCK, OUTPUT);
  pinMode(B_RESET, OUTPUT);
  pinMode(B_RD, INPUT);
  pinMode(B_WR, INPUT);
  pinMode(B_IO, INPUT);

  for(int pin = 0; pin < 8; pin++)  pinMode(pinsData[pin], INPUT);
//  for(int pin = 0; pin < 8; pin++)  pinMode(pinsData[pin], OUTPUT);

  SPI.setClockDivider(SPI_CLOCK_DIV128);
  SPI.setDataMode(SPI_MODE0);
  SPI.setBitOrder(MSBFIRST);
  SPI.begin();

  Serial.begin(115200);
  delay(25);

  Serial.println("Reset Z80");
  Serial.println(sizeof(mem));
  doReset();

  delay(10);

  attachInterrupt(digitalPinToInterrupt(B_RD), readISR, FALLING);
  attachInterrupt(digitalPinToInterrupt(B_WR), writeISR, FALLING);
}

void loop() {
  unsigned int addr;

  if(doread) {
    if(digitalRead(B_IO)) {
      //delay(1);
      addr = getaddr();
//      Serial.print("Adresse: 0x");
//      if(addr < 0x10)   Serial.print("0");
//      if(addr < 0x100)  Serial.print("0");
//      if(addr < 0x1000) Serial.print("0");
//      Serial.print(addr, HEX);

      if(addr >= 0 && addr <sizeof(mem)) {
        setData(mem[addr]);
//        Serial.print(" [0x");
//        if(mem[addr] < 0x10)   Serial.print("0");
//        Serial.print(mem[addr], HEX);
//        Serial.println("]");
      } else {
        setData(0x00);
        Serial.println(" !!!!!");
      }
    } else {
      Serial.print(" IOREQ R: ");
      Serial.print(" port= ");
      Serial.print(getaddr() & 255);
      Serial.print(" data= ");
      Serial.println(getData(), HEX);
    }
    doread=0;
  } else if(dowrite) {
    if(digitalRead(B_IO)) {
      // Récupération de l'adresse
      addr = getaddr();
      // Affichage
//      Serial.print("Adresse: 0x");
//      if(addr < 0x10)   Serial.print("0");
//      if(addr < 0x100)  Serial.print("0");
//      if(addr < 0x1000) Serial.print("0");
//      Serial.print(addr, HEX);

      // Si l'adresse est valide (dans les 64 octets de mémoire)
      if(addr >= 0 && addr < sizeof(mem)) {
        // On "place" les données correspondante du bus en mémoire
        mem[addr] = getData();
        // Et on affiche le tout
//        Serial.print(" [0x");
//        if(mem[addr] < 0x10)   Serial.print("0");
//        Serial.print(mem[addr], HEX);
//        Serial.println("] W");
      } else {
        // Nous sommes hors de l'espace mémoire émulé
        Serial.println(" !!!!! W");
      }
    } else {
      Serial.print(" IOREQ W: ");
      Serial.print(" port= ");
      Serial.print(getaddr() & 255);
      Serial.print(" data= ");
      Serial.println(getData(), HEX);
    }
    // On confirme la prise en charge
    dowrite=0;
  }

  doClock(1);
  for( int pin = 0; pin < 8; pin++ ) pinMode(pinsData[pin], INPUT);  // input
}
